<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.0.16 (451861)"/><meta name="altitude" content="16.35442543029785"/><meta name="author" content="markselby"/><meta name="created" content="2015-11-10 02:24:12 +0000"/><meta name="latitude" content="31.19377990873135"/><meta name="longitude" content="121.5955060654452"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2015-11-18 02:18:50 +0000"/><title>《Build your own angularJS》Part 1: Scope</title></head><body>
<div>Chapter 0：环境设置</div>
<div>nam, karma, phantomJS, Browserify，jshint(代码检查，lint)</div>
<div>墙内用cnpm代理即可</div>
<div>hello.js 和 hello_spec.js，第一个Karma测试</div>
<div><br/></div>
<div>dollar符号、_符号：对于interpreter来说没有特殊意义</div>
<div>loads.js中的_：provide more consistent cross-environment iteration support for arrays, strings, objects, and arguments objects</div>
<div><span style="color: rgb(255, 38, 0);">==== lodash === 很有用的npm库</span></div>
<div><a href="https://lodash.com/docs">https://lodash.com/docs</a></div>
<div>Part1 中用到了:</div>
<div>_.forEach(collection, [iteratee=_.identity], [thisArg])</div>
<div>_.indexOf(array, value, [fromIndex=0])</div>
<div>_.rest(array) （数组的第一个元素之后的元素）</div>
<div>等很有用的方法</div>
<div><br/></div>
<div>Part 1 : Scope</div>
<div>Chapter 1: Scopes and Digest</div>
<div>Watching Object: $watch and $digest</div>
<div><br/></div>
<div>$watch:</div>
<div>1, a watch function, specifies the piece of data you’re interested in</div>
<div>Angular中通常是watch expression</div>
<div>2, a listener function, will be called whenever the data changes</div>
<div>$digest:</div>
<div>遍历scope中的所有watchers，</div>
<div>dirty-checking: 检查watch functions对应的值是否真的改变了，如果改变了再调用listener function</div>
<div>过程：调用watch function，比较这次和上次的结果，如果结果不同则这个watcher是dirty的，需要调用listener function</div>
<div><br/></div>
<div>var self=this; 针对Javascript对于this的绑定的处理方法，</div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(0.000000%, 44.000000%, 13.000000%)">Scope</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(0.000000%, 44.000000%, 13.000000%)">prototype</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(2.000000%, 16.000000%, 49.000000%)">$digest</span> <span style="font-size: 9.000000pt; font-family: 'LMMono9'">=</span> <span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">function</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">() {<br/></span><span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">var</span> <span style="font-size: 9.000000pt; font-family: 'LMMono9'">self =</span> <span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">this</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">;</span></div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(0.000000%, 44.000000%, 13.000000%)">_</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(2.000000%, 16.000000%, 49.000000%)">forEach</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">(</span><span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">this</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(2.000000%, 16.000000%, 49.000000%)">$$watchers</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">,</span> <span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">function</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">(watcher) {</span></div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(0.000000%, 44.000000%, 13.000000%)">   watcher</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(2.000000%, 16.000000%, 49.000000%)">watchFn</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">(self);<br/></span></div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(0.000000%, 44.000000%, 13.000000%)">   watcher</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(2.000000%, 16.000000%, 49.000000%)">listenerFn</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">();</span></div>
<div><span style="font-size: 9pt;"><span style="font-family: LMMono9;"> });</span></span></div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMono9'">};</span></div>
<div><br/></div>
<div>此时体现出了：</div>
<div>1，Angular Scope只会遍历所有的watches，不会遍历所有的属性</div>
<div>2，每一个watch function都在$digest的时候被调用。</div>
<div><br/></div>
<div>实现dirty checking: $digest中遍历所有watcher时，比较每个watch function返回值和之前保存的是否不同，function(watcher)中有newValue和oldValue属性。oldValue应该被初始化，而不是undefined.</div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(0.000000%, 44.000000%, 13.000000%)">Scope</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(0.000000%, 44.000000%, 13.000000%)">prototype</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(2.000000%, 16.000000%, 49.000000%)">$digest</span> <span style="font-size: 9.000000pt; font-family: 'LMMono9'">=</span> <span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">function</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">() {</span> <span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">var</span> <span style="font-size: 9.000000pt; font-family: 'LMMono9'">dirty;</span></div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">do</span> <span style="font-size: 9.000000pt; font-family: 'LMMono9'">{</span></div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMono9'">dirty =</span> <span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">this</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">.</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'; color: rgb(2.000000%, 16.000000%, 49.000000%)">$$digestOnce</span><span style="font-size: 9.000000pt; font-family: 'LMMono9'">(); }</span> <span style="font-size: 9.000000pt; font-family: 'LMMonoLt10'; font-weight: 700; color: rgb(0.000000%, 44.000000%, 13.000000%)">while</span> <span style="font-size: 9.000000pt; font-family: 'LMMono9'">(dirty);</span></div>
<div><span style="font-size: 9.000000pt; font-family: 'LMMono9'">};</span></div>
<div>此时体现出Angular 的watch function：</div>
<div>3，idempotent，watch function应该没有副作用，<span style="font-size: 9.000000pt; font-family: 'LMRoman9'">They may be run many times per each digest pass</span></div>
<div><br/></div>
<div>关于比较的时候基于值还是基于引用？添加一个bool变量，</div>
<div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="background-color:#e4e4ff;">Scope</span>.<span style="color:#7a7a43;">prototype</span>.<span style="color:#7a7a43;">$$areEqual </span>= <span style="color:#000080;font-weight:bold;">function</span>(newValue, oldValue, valueEq){<br/>
    <span style="color:#000080;font-weight:bold;">if </span>(valueEq){<br/>
        <span style="color:#000080;font-weight:bold;">return </span><span style="color:#660e7a;font-weight:bold;font-style:italic;">_</span>.<span style="color:#660e7a;font-weight:bold;">isEqual</span>(newValue, oldValue);<br/>
    } <span style="color:#000080;font-weight:bold;">else</span>{<br/>
        <span style="color:#000080;font-weight:bold;">return </span>oldValue===newValue || (<span style="color:#000080;font-weight:bold;">typeof </span>newValue === <span style="color:#008000;font-weight:bold;">'number' </span>&amp;&amp; <span style="color:#000080;font-weight:bold;">typeof </span>oldValue === <span style="color:#008000;font-weight:bold;">'number' </span>&amp;&amp; <span style="color:#7a7a43;">isNaN</span>(newValue) &amp;&amp; <span style="color:#7a7a43;">isNaN</span>(oldValue));<br/>
    }<br/>
};<br/></div>
</div>
<div><br/></div>
<div>如果两个digest在互相watch对方的改变时，会有死循环？设置一个ttl，如果ttl到0了则抛出错误。</div>
<div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="color:#000080;font-weight:bold;">do</span>{ <span style="color:#808080;font-style:italic;">//Outer loop, run when changes keep occurring<br/></span><span style="color:#808080;font-style:italic;">   </span> <span style="color:#458383;">dirty </span>= <span style="color:#000080;font-weight:bold;">this</span>.<span style="color:#7a7a43;">$digestOnce</span>();<br/>
    <span style="color:#000080;font-weight:bold;">if </span>(<span style="color:#458383;">dirty </span>&amp;&amp; !(<span style="color:#458383;">ttl</span>--)){<br/>
        <span style="color:#000080;font-weight:bold;">throw </span><span style="color:#008000;font-weight:bold;">"10 digest iterations reached"</span>;<br/>
    }<br/>
} <span style="color:#000080;font-weight:bold;">while </span>(<span style="color:#458383;">dirty</span>);<br/></div>
</div>
<div><br/></div>
<div>性能优化：之前每次digest都是遍历所有watcher，如果遇到一个clean watch是上次的dirty watch，意思是已经遍历过一遍了，并且没有dirty watch，那么当前遍历也没有必要完全进行了，可以减少遍历次数。通过修改dirty布尔值，中止当前digest的遍历。</div>
<div>value-based equal： Angular在做dirty checking的时候默认不做基于值的，而是需要显式设置才会做值的比较。</div>
<div>NaN(Not a number)在JavaScript中总是跟自己不相等的，即NaN=NaN。</div>
<div><br/></div>
<div>$eval：执行参数内的函数</div>
<div>$apply：将外部的库引入到Angular的方法，执行一些Angular不知道的代码。</div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="background-color:#e4e4ff;">Scope</span>.<span style="color:#7a7a43;">prototype</span>.<span style="color:#7a7a43;">$apply </span>= <span style="color:#000080;font-weight:bold;">function</span>(expr){<br/>
    <span style="color:#000080;font-weight:bold;">try</span>{<br/>
        <span style="color:#000080;font-weight:bold;">return this</span>.<span style="color:#7a7a43;">$eval</span>(expr);<br/>
    }<span style="color:#000080;font-weight:bold;">finally</span>{<br/>
        <span style="color:#000080;font-weight:bold;">this</span>.<span style="color:#7a7a43;">$digest</span>();<br/>
    }</div>
<div><span style="font-size: 12pt;"><span style="font-family: Menlo;">};</span></span></div>
<div><span style="font-size: 12pt;"><span style="font-family: Menlo;"> </span></span></div>
<div>NaN(Not a number)在JavaScript中总是跟自己不相等的，即NaN=NaN。</div>
<div><br/></div>
<div>deferred execution: AngularJS 自带 $timeout service，</div>
<div>这里实现$evalAsync，一段代码延迟执行（但仍然在当前$digest内执行）</div>
<div>scope内添加一个$$asyncQueue，延迟的代码放在Queue内，然后在$digest中的一次遍历里遍历这个Queue，执行所有task</div>
<div><br/></div>
<div>$applyAsync: 优化连续快速发生的时间，让他们在一次digest中完成。</div>
<div><br/></div>
<div>$$postDigest: 在一个Digest之后运行代码，双美元符号代表是Angular的内部函数。</div>
<div>错误处理：Angular有$errorservice处理错误，这里暂时只打印出来。例如</div>
<div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="color:#000080;font-weight:bold;">while </span>(<span style="color:#000080;font-weight:bold;">this</span>.<span style="color:#660e7a;font-weight:bold;">$$applyAsyncQueue</span>.<span style="color:#660e7a;font-weight:bold;">length</span>){<br/>
    <span style="color:#000080;font-weight:bold;">try</span>{<br/>
        <span style="color:#000080;font-weight:bold;">this</span>.<span style="color:#660e7a;font-weight:bold;">$$applyAsyncQueue</span>.<span style="color:#7a7a43;">shift</span>()();<br/>
    } <span style="color:#000080;font-weight:bold;">catch </span>(e){<br/>
        <span style="color:#660e7a;font-weight:bold;font-style:italic;">console</span>.<span style="color:#7a7a43;">error</span>(e);<br/>
    }<br/>
}<br/></div>
</div>
<div><br/></div>
<div>$watchGroup: 一个listener监听多个changes，包装在一个array里。不要实现成一有变化就马上调用listener，而是多次变化之后只调用一次listener</div>
<div><br/></div>
<div>第一章总结：</div>
<ol>
<li>Angular的dirty checking，process包括了 $watch 和 $digest</li>
<li>dirty-checking的循环，TTL的机制确保不会无限循环</li>
<li>关于===，基于引用还是基于值？</li>
<li>在digest循环中执行函数的两种方式：$eval,$apply马上执行，$evalAsync,$applyAsync,$$postDigest是稍后执行</li>
<li>Exception的处理</li>
<li>销毁watches</li>
<li>$watchGroup同时监视多个对象</li>
</ol>
<div><br/></div>
<div>第二章 Scope Inheritance</div>
<div>Angular的Scope inheritance机制是在Javascript prototypal object inheritance的机制的基础上添加一些内容得到的。</div>
<div>child scope继承parent scope的属性，两者是同一个引用，child scape可以修改parent scape的该属性，也可以watch之。</div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="background-color:#e4e4ff;">Scope</span>.<span style="color:#7a7a43;">prototype</span>.<span style="color:#7a7a43;">$new </span>= <span style="color:#000080;font-weight:bold;">function</span>(){<br/>
    <span style="color:#000080;font-weight:bold;">var </span><span style="font-style:italic;">ChildScape </span>= <span style="color:#000080;font-weight:bold;">function</span>(){};<br/>
    <span style="font-style:italic;">ChildScape</span>.<span style="color:#660e7a;font-weight:bold;">prototype </span>= <span style="color:#000080;font-weight:bold;">this</span>;<br/>
    <span style="color:#000080;font-weight:bold;">var </span><span style="color:#458383;">child </span>= <span style="color:#000080;font-weight:bold;">new </span><span style="font-style:italic;">ChildScape</span>();<br/>
    <span style="color:#000080;font-weight:bold;">return </span><span style="color:#458383;">child</span>;</div>
<div><span style="font-size: 12pt;"><span style="font-family: Menlo;">};</span></span></div>
<div><span style="font-size: 12pt;"><span style="font-family: Menlo;">或者</span></span></div>
<div><span style="font-size: 12pt;"><span style="font-family: Menlo;"><span style="background-color:#e4e4ff;">Scope</span>.<span style="color:#7a7a43;">prototype</span>.<span style="color:#7a7a43;">$new </span>= <span style="color:#000080;font-weight:bold;">function</span>(){</span></span></div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="color:#808080;font-style:italic;">   </span> <span style="color:#000080;font-weight:bold;">var </span><span style="color:#458383;">child </span>= Object.<span style="color:#7a7a43;">create</span>(<span style="color:#000080;font-weight:bold;">this</span>);<br/>
    <span style="color:#000080;font-weight:bold;">return </span><span style="color:#458383;">child</span>;<br/>
};<br/></div>
<div>（这一段就是Javascript的继承）</div>
<div>shadowing：child scope对parent scope的属性做的修改，只在child及之后的scope chain上被应用。（覆盖）</div>
<div><br/></div>
<div>dot rule: Whenever you use ngModel, there’s got to be a dot in there somewhere. If you don’t have a dot, you’re doing it wrong.</div>
<div>child scope的$$watchers不应该继承parent的，初始化为[]</div>
<div>$digest不应该往chain的上方查找，而是应该向下查找。$$digestOnce需要顺着hierarchy向下遍历。</div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="background-color:#e4e4ff;">Scope</span>.<span style="color:#7a7a43;">prototype</span>.<span style="color:#7a7a43;">$$everyScope </span>= <span style="color:#000080;font-weight:bold;">function</span>(fn){<br/>
    <span style="color:#000080;font-weight:bold;">if </span>(fn(<span style="color:#000080;font-weight:bold;">this</span>)){<br/>
        <span style="color:#000080;font-weight:bold;">return this</span>.<span style="color:#660e7a;font-weight:bold;">$$children</span>.<span style="color:#7a7a43;">every</span>(<span style="color:#000080;font-weight:bold;">function</span>(child){<br/>
            <span style="color:#000080;font-weight:bold;">return </span>child.<span style="color:#7a7a43;">$$everyScope</span>(fn); <span style="color:#808080;font-style:italic;">//recursively invoke fn on child<br/></span><span style="color:#808080;font-style:italic;">       </span> });<br/>
    }<span style="color:#000080;font-weight:bold;">else</span>{<br/>
        <span style="color:#000080;font-weight:bold;">return false</span>;<br/>
    }</div>
<div><span style="font-size: 12pt;"><span style="font-family: Menlo;">};</span></span></div>
<div>$apply则应该直接从根节点开始遍历</div>
<div><br/></div>
<div>isolated scopes: 部分继承，但是不是全部继承，脱离parent scope的prototype chain。设置Scope.$new(isolated)，isolated=true，构造一个new Scope()，并继承parent Scope的$root，$$asyncQueue, $$postDigestQueue</div>
<div>Substituting the parent scope：$new()函数添加新的参数，选择一个scope作为新scope的parent</div>
<div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="color:#000080;font-weight:bold;">var </span><span style="color:#458383;">parent </span>= parent || <span style="color:#000080;font-weight:bold;">this</span>;<br/></div>
</div>
<div><br/></div>
<div>Destroy a scope：移除所有的watchers，从parent的$$children数组中移除，然后等待Javascript gc。</div>
<div><br/></div>
<div>Summary：</div>
<ol>
<li>child scope的继承，如何创建</li>
<li>scope inheritance 和 prototypal inheritance的关系</li>
<li>属性覆盖</li>
<li>recursive digestion</li>
<li>$digest和$apply的区别</li>
<li>Isolated scopes和一般child scope的区别</li>
<li>destroy a scope</li>
</ol>
<div><br/></div>
<div>第三章：Watching Collections</div>
<div>之前的value based $watch，需要保留old value的deep clone，并且需要递归的比较，$watchCollection对此做一些优化</div>
<div><img src="%E3%80%8ABuild%20your%20own%20angularJS%E3%80%8BPart%201%3A%20Scope.resources/9CA94F28-2431-4387-9CA9-4E62EAF0E59A.png" height="623" width="737"/></div>
<div>$watchCollection关注arrays and objects，如果watch function返回non-collection则等同于$watch。</div>
<div>internalWatchFunction应该返回什么呢？重要的只是在连续的调用返回值中有没有做改变，因为对于$watchCollection函数的外部来说怎么改变是不重要的。Angular的做法：对于每个internalWatchFunction，用一个integer counter。</div>
<div style="background-color:#ffffff;color:#000000;font-family:'Menlo';font-size:12.0pt;"><span style="color:#000080;font-weight:bold;">var </span><span style="font-style:italic;">internalWatchFn </span>= <span style="color:#000080;font-weight:bold;">function</span>(scope){<br/>
    <span style="color:#458383;">newValue </span>= watchFn(scope);<br/>
    <span style="color:#808080;font-style:italic;">//check for changes<br/></span><span style="color:#808080;font-style:italic;">   </span> <span style="color:#000080;font-weight:bold;">if </span>(<span style="color:#458383;">newValue </span>!= <span style="color:#458383;">oldValue</span>){<br/>
        <span style="color:#458383;">changeCount</span>+=<span style="color:#0000ff;">1</span>;<br/>
    }<br/>
    <span style="color:#458383;">oldValue </span>= <span style="color:#458383;">newValue</span>;<br/>
    <span style="color:#000080;font-weight:bold;">return </span><span style="color:#458383;">changeCount</span>;</div>
<div><span style="font-size: 12pt;"><span style="font-family: Menlo;">};</span></span></div>
<div>对于NaN，因为NaN!=NaN，所以!=要改成之前实现的 self.$$areEqual。_.isNaN(newValue)&amp;&amp;_.isNaN(oldValue)</div>
<div><br/></div>
<div>对于watch的对象是（类）数组，newValue和oldValue先比较数据类型，再比较长度，再逐个遍历比较，这样可以避免每次都要遍历数组以及内部结构</div>
<div>_.isArray只判断是否为数组，需要考虑类似数组的数据结构，如dom node list或者argument list，也当做数组看待</div>
<div><br/></div>
<div>对于watch的对象不是数组，是Object，先比较数据类型，然后遍历所有new object中的属性，和old object作比较，再遍历所有old object的属性，移除new object没有的属性。</div>
<div>这样需要遍历两遍，比较昂贵，优化：记录old object和new object的长度，做长度的比较。</div>
<div><br/></div>
<div>总结：</div>
<ol>
<li>$watchCollection ： 我们可以更高效地监视大的array和object，而不用递归比较</li>
<li>如何处理arrays, objects, array-like objects, other values.</li>
</ol>
<div><br/></div>
<div>Chapter 4: Event System</div>
<div>Angular也是采用publish/subscribe messaging pattern，但是有一点不同：The Angular event system is baked into the scope hierarchy. Rather than having a single point through which all events flow, we have the scope tree where events may propagate up and down. 当publish的时候可以选择向上还是向下，向上是emit（current and ancestor），向下是broadcast（current and descendent）</div>
<div>$on(event name, listener function)</div>
<div><br/></div>
<div>Event object: Angular调用Listeners的机制，同样的event object被传递给每个listener，developer可以添加额外的属性来进行listener之间的通信</div>
<div>var event = {name: eventName}</div>
<div>另外$emit和$broadcast都会在调用完之后返回他们的event object，这样调用者可以在每次调用完之后检查event object的状态。</div>
<div>Angular scope event 有一对属性和DOM event累死，targetScope表示event在哪个scope上出现，currentScope表示listener在哪个scope上。</div>
<div><br/></div>
<div>stopPropagation: 只能在emitted event使用，broadcast不能停止。</div>
<div>preventDefault: Javascript中组织DOM的默认行为，如点击超链接不跳转。Angular中同样，一个布尔值决定是否执行event object的default behavior。</div>
<div><br/></div>
<div>$destroy: destroy a scope (and its children)，this.broadcast(‘$destroy')</div>
<div>Handling exception：listener function发生异常时，不应停止propagating。现在每个emit或者broadcast出现exception时均向外抛出。</div>
<div><br/></div>
<div>总结：</div>
<ol>
<li>publish/subscribe pattern</li>
<li>Angular注册listeners，发生事件的机制</li>
<li>$emit和$broadcast的区别</li>
<li>scope event object</li>
<li>stopPropagation, preventDefault, $destroy</li>
<li>exception handler</li>
</ol>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
<div><br/></div>
</body></html>